
############################################################
# Parallelize a for-loop by rewriting it as an lapply call #
############################################################

#https://www.r-bloggers.com/parallelize-a-for-loop-by-rewriting-it-as-an-lapply-call/amp/

num <- 1:5
y <- list()
for (i in seq_along(num)){
 x <- num[[i]]
 tmp <- sqrt(x)
 y[[i]] <- tmp
}
y

#Modification to remove "side-effects" of the loop:
y <- list()
for (i in seq_along(num)){
 y[[i]] <- local({ #local() enforces that variables are looked up in the local environment and not in the global environment. See https://stackoverflow.com/questions/6216968/r-force-local-scope
 x <- X[[i]]
 tmp <- sqrt(x)
 tmp
 })
}
y

#Now as lapply call:
y <- lapply(1:5, function(x){
 tmp <- sqrt(x)
 tmp
})

#Or how I would have done it:
lapply(1:5, sqrt)

#slightly more complex:
system.time(y <- lapply(1:5, function(x){
 tmp1 <- sqrt(x)
 tmp2 <- x^2
 list(y=tmp1, z=tmp2)
})) #approximately 1,5 - 1,6 seconds on my laptop
y

#parallelize:
library(future.apply)
plan(multiprocess)

k <- 1:100000
system.time(y <- future_lapply(k, function(x){
 tmp1 <- sqrt(x)
 tmp2 <- x^2
 list(y=tmp1, z=tmp2)
}))
y

